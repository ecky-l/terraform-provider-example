\documentclass[paper=a4,11pt,numbers=noenddot]{article}
\linespread{1.2}
\usepackage[parfill]{parskip} % non-indented paragraphs with more space
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[pdftex]{color,graphicx}

\usepackage[autocite=plain, backend=biber, style=numeric, sorting=nyt]{biblatex}
%\addbibresource{main.bib} % The filename of the bibliography
\bibliography{main}
\nocite{*}

\usepackage{listings}
\renewcommand{\lstlistlistingname}{List of Listings}
\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\scriptsize,
  numbers=none,
  backgroundcolor=\color[rgb]{0.95,0.90,0.90},
  commentstyle=\color[rgb]{0,0.6,0},
  keywordstyle=\color[rgb]{0.2,0.6,1},
  breakatwhitespace=false,
  breaklines=true,
%  captionpos=b,
  keepspaces=true,
%  numbers=left,
%  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mystyle}

\usepackage[plainpages=false,pdfpagelabels,hidelinks]{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=blue,
}
\urlstyle{same}

%% margins
\oddsidemargin 0cm
\evensidemargin 0cm
\textwidth 16cm
\topmargin 0cm
%\textheight 24.37cm

\title{Terraform Provider Development}
\author{Eckhard Lehmann}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

Here at OTTO we work with many different IT systems, for example to provide the online shop, process orders and shipments or manage customer data. Many of them are self developed and we use a mixture of on-premise and cloud infrastructure to host the services of which they consist. Since release and deploy time matters, as well as traceability of changes in deployment cycles, most teams use \emph{Infrastructure as Code} (\emph{IaC})~\autocite{morris_infrastructure_as_code_2025} and declarative configuration management as much as possible. Most of the deployments and infrastructure changes within my team are managed by terraform~\autocite{noauthor_terraform_nodate} and most of the time we can use what is already provided in the terraform ecosystem.

But sometimes this is not the case. We develop and run a service to manage permissions for topics in the asynchronous messaging system \emph{Apache Kafka} in the \emph{Confluent Cloud}~\autocite{noauthor_apache_kafka_nodate, noauthor_confluent_nodate} and our customers are other development teams within the company, who use kafka on confluent for message and data exchange among and within their systems. They also use terraform, and there is no official provider available for our in-house API.\ Therefore we have the chance to develop a terraform provider for our service.

In this article I will present what we learned about terraform provider development by using a small and artificial example. For this example I extracted the things we learned (so far) during the course of our in-house provider development, and reshaped it to be easy to follow without in-house knowledge. Section~\ref{sec:technology-overview} gives a short overview over the used and necessary technologies. Section~\ref{sec:simple-rest-api} presents a mocked API that is used as a ``backend'' for the example and in Section~\ref{sec:creat-terr-prov} the provider example itself is described from two perspectives. Finally, Section~\ref{sec:summary} summarizes the results. The whole text is closely related to the \emph{terraform-provider-example} github repository~\autocite{ecky-l_terraform-provider-example_nodate}, so you might want to clone this repository and look at it while you continue to read.

\section{Technology Overview}
\label{sec:technology-overview}

As with most of today's software development challenges, there are already technologies, tools and frameworks available on which can be built upon. Terraform itself is programmed in \emph{Go} and the easiest way is to use \emph{Go} as well for provider development\footnote{Terraform communicates with providers via RPC, so strictly speaking it would be possible to use any programming language that is capable of RPC, but a high level SDK is only available for \emph{Go}.}. Therefore this section gives a very brief introduction to \emph{Go} and the terraform ecosystem itself.

\subsection{The Go Programming Language}
\label{subsec:go-progr-lang}

Go, or ``golang'' is a modern, general purpose programming language introduced by Google. It is a statically typed and compiled language, which means it comes with the advantage that type checking is done at compile time. Golang has its roots in C, Pascal/Oberon and languages that stem from the concept of \emph{communicating sequential processes} (CSP), like Squeak and Alef \autocite{donovan_go_2016}. From the latter it inherits its model of concurrent programming, which is quite outstanding among programming languages and makes Go an interesting choice for parallel programming tasks.

When looking at golang code, the most prominent heritage is from the C programming language. Thus golang is sometimes referred to as \emph{C for the 21st century}. But despite the outside looks quite much like C, there is not much C under the hood. Go has garbage collection, object orientation, memory safety, type-safe pointers and functional elements, which means functions can be bound to arguments, return values and variables, including declaration scope. Additionally it comes with a modern tool set that enables dependency management, testing, documentation generation from source code comments, linting and other tasks to be performed in an everyday usage of the language. All this is combined in the \verb'go' tool, which is the entry- and starting point for every golang project.

The website \url{https://go.dev/} is the main entry point for resources to download and learn golang, including a nice tutorial called a \emph{Tour of Go}. For serious ambitions in developing terraform providers it is a good idea to look at this tutorial and get comfortable with the golang distribution and the \verb'go' tool at least, as everything around terraform and its providers is developed in golang.

\subsection{The \emph{terraform} tool and ecosystem}
\label{subsec:terr-tool-ecosyst}

Terraform is a tool for managing \emph{Infrastructure as Code} (\emph{IcA}). At the heart is a terraform \emph{state}, a JSON file with a specific structure, that describes the current state of a certain infrastructure in form of its \emph{resources} and a set of resource definitions in \verb'.tf' files inside a directory, called a \emph{terraform module}. To create a infrastructure module, files with the ending \verb'.tf', containing resource definitions are placed in a directory. As a simple, artificial example consider a resource \emph{employee} with certain attributes:

\begin{lstlisting}
resource "shop_article" "shampoo" {
  name        = "Princess Rosalea"
  description = "Child Shampoo & Conditioner"
}
\end{lstlisting}

In reality these are computer resources, such as networks, databases, virtual machine instances, etc. Terraform resources are used to describe conglomerations of computer infrastructure in cloud environments. Thus there is always some kind of \emph{backend} involved, usually a REST API, which implements the logic to provide the respective resources in a cloud environment.

The \verb'terraform' command is used to read the \verb'.tf' files in a directory, take the necessary actions to create the resources (i.e.\ calls the API endpoints), and store the state into a state file. This state file is by default a local JSON file called \verb'terraform.tfstate', but can be configured to reside in a remote location, such as an cloud storage bucket or a database. Whenever resources need to be changed or deleted, or additional resources should be created, the respective resource definitions in the \verb'tf' files can be edited, deleted or extended by new resources. A \verb'terraform apply' would then do three things:

\begin{enumerate}
\item\label{itm:tf-read} Get the current resources in the backend.
\item\label{itm:tf-compare} Do a three-way compare between the current state, the fetched real resources and the resource (\verb'tf') files, and then:
  \begin{itemize}
  \item Delete resources that are in the backend but not in the resource files.
  \item Create resources that are not in the backend, but in the resource files.
  \item Modify resources whose definition has changed in the resource files, compared to the previous definition in the state.
  \end{itemize}
\item\label{itm:tf-create-update} Store the new state in the state file.
\end{enumerate}

Terraform provides its functionality by means of a core component that reads the \verb'.tf' files and manages the state, and a set of plugins, which interact with various backends. These plugins are called \emph{providers}, as they provide the functionality of infrastructure management. They are decoupled from the terraform core and evolve independently. Providers are available for all well-known cloud providers and various other infrastructure providing entities, such as the IAM solution Keycloak \autocite{team_keycloak_nodate} or the secret manager Vault \autocite{noauthor_vault_nodate}.

An entry point for searching terraform providers and their documentation is the terraform provider registry~\autocite{noauthor_terraform_registry_nodate}. There are numerous resources available on terraform with the main entry point being its homepage~\autocite{noauthor_terraform_nodate}. A good introduction with live examples can also be found in~\autocite{brikman_terraform_2022}.


\section{A Simple REST API Backend}
\label{sec:simple-rest-api}

The purpose of terraform is to manage infrastructure as code, that is to create, modify and delete infrastructure \emph{resources}. How exactly these resources look like, is not strictly specified. On a cloud provider like AWS or GCP it might be virtual hardware resources, or firewall and permission rules, while on a keycloak instance it might be OpenID Connect Clients and appropriate credentials. On a local machine it might be files in the file system, service management scripts or mandatory access control policies (such as for SElinux).

However, to keep things simple we will consider a simple REST API backend for the purpose of this demonstration, where the resources are shop articles. Moreover we will not even create this backend - instead we will mock it. Wiremock~\autocite{noauthor_wiremock_nodate} is a powerful tool and library, which fulfills the sole objective to return specific responses based on certain matching input criteria. It is normally used to unit-test API clients in a variety of programming languages, when the genuine API backend is not (yet) available or should not be stressed for testing.

\paragraph{The \emph{article} REST Resource}

Our REST API manages a resource called \emph{shop\_article}, which is essentially an online shop article. It contains an ID, a name and a description. Articles can be created, fetched by ID, updated and deleted. Although this is oversimplified, it is enough for the purpose of an illustrative example.

The management of our REST resource can be described as a state machine: Initially there is no article, so a \verb'GET' call to a specific ID, say \emph{1}, will return a HTTP status 404. This is state $S_0$, or ``Started''. When a \verb'POST' is made to the \verb'/articles' endpoint, an article is created initially with a specific ID, say \emph{1}, and the state for this entity changes to $S_1$, or \emph{Article added}. A \verb'GET' call to \verb'/articles/1' in $S_1$ retrieves the initially created article. Now there are two possibilities to change the state again: A \verb'PUT' call to \verb'/articles/1' modifies the article and changes the state to $S_2$, or \emph{Article modified}. Subsequent \verb'GET' calls to \verb'/articles/1' will retrieve the modified article. A \verb'DELETE' call to \verb'/articles/1' will ``delete'' the article in either $S_1$ or $S_2$ and reset the state to $S_0$. Subsequent modifications or specific create/update parameters are not considered.

In Wiremock this can be depicted as a \emph{Scenario}~\autocite{noauthor_wiremock_stateful_behavior_2025}. Our article is a children shampoo and the corresponding file can be found~\href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/wiremock/mappings/shampoo.json}{here} in the github repository of this example~\autocite{ecky-l_terraform-provider-example_nodate}. Create a directory \emph{mappings} and place the file into this directory. Then download the standalone binary from the \emph{Wiremock} homepage, place it aside the \emph{mappings} directory and start wiremock up with \verb'java -jar wiremock-standalone-<version>.jar'. You should see the service starting up and listening on port \verb'8080'. Then you can verify whether our new ``API backend'' works:

\begin{lstlisting}[language=bash]
$ curl -s localhost:8080/articles/1 | jq
{
  "error": "not found"
}
$ curl -sX POST localhost:8080/articles | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner"
}
$ curl -s localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner."
}
$ curl -sX PUT localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner. Soft on the skin, soft on the environment."
}
$ curl -s localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner. Soft on the skin, soft on the environment."
}
$ curl -X DELETE localhost:8080/articles/1
$ curl -s localhost:8080/articles/1 | jq
{
  "error": "not found"
}
\end{lstlisting}

This is about all we need to back the \emph{shop\_article} resource for our demo terraform provider, which will be the topic of the next sections.

\section{Creating a Terraform Provider with one Resource}
\label{sec:creat-terr-prov}

Communication between the terraform core and the providers is implemented via an RPC interface and callback functions that are executed at specific points in the interaction~\ref{itm:tf-read}-~\ref{itm:tf-create-update} in Section~\ref{subsec:terr-tool-ecosyst}.

\subsection{The Practitioner's View}
\label{subsec:practitioners-view}

A \emph{practitioner} is, as frequently denoted in the terraform plugin framework~\autocite{noauthor_terraform_framework_nodate}, the person who manages infrastructure as code in terraform. His point of view is a set of \verb'.tf' files in a directory, which makes up a terraform module. He is using the resources and data sources that a terraform provider provides and he is mostly concerned about creating and maintaining resources as code, as well as about installing and updating providers. His infrastructure should be kept stable among those installations and updates. A good introduction and guideline on the practitioner's view of terraform is~\autocite{brikman_terraform_2022}. In this section we will see how the world looks like from his perspective.

\subsubsection{An example terraform module}
\label{subsubsec:an-example-terraform}

For our example, there is a terraform module (directory) with one file \verb'main.tf'. The content of this file looks like listing~\ref{lst:example.tf} and can be found~\href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/exampletf}{here} in the github repository~\autocite{ecky-l_terraform-provider-example_nodate}.

\begin{lstlisting}[label=lst:example.tf]
terraform {
  required_providers {
    example = {
      source  = "example.com/tfp-example/example"
      version = "0.0.1"
  }
}

provider "example" {
  host = "http://localhost:8080"
}

resource "example_shop_article" "example" {
  name        = "Princess Rosalea"
  description = "Child Shampoo & Conditioner"
}
\end{lstlisting}

Each terraform main module\footnote{There are also sub modules, which do not necessarily contain all configuration options when used in other (main) modules.} contains at least one \verb'terraform' block in which the \emph{required providers} are configured. Each provider is listed by its name and the source where it can be downloaded. The required version is optional, otherwise the latest version is resolved and used. It follows an optional \verb'provider' block for each required provider, in which special configuration can be passed. Afterwards, the resources and data sources of the provider can be used.

A \verb'terraform init' in the directory with the terraform sources fetches the provider from the specified source and extracts it in the local \emph{.terraform} directory. A subsequent \verb'terraform plan' shows what is going to happen, i.e.\ creating the specified resource. Then, a \verb'terraform apply' would actually execute the plan. When these commands are run, terraform communicates with the provider and calls a set of functions that are described in the following.


\subsubsection{Provider Installation}
\label{subsubsec:prov-inst}

The \verb'source' parameter in the \verb'required_providers' block has a special structure which specifies where the provider's binary release can be found. It consists of three parts:

\begin{itemize}
\item The domain where the provider release resides.
\item A name space for the provider, usually a team or company who is maintaining the provider
\item The provider's name
\end{itemize}

As a consequence, the source has always the schema \emph{<domain>/<namespace>/<provider name>}. Most providers are hosted on the terraform provider registry~\autocite{noauthor_terraform_registry_nodate}, therefore the domain \emph{registry.terraform.io} for those providers can be omitted for convenience. Otherwise it must be a valid domain under which a web server is hosting the provider binaries within the directory structure \emph{<namespace>/<provider name>}. In there, the releases must have a name that follows the schema \emph{terraform-provider-<name>\_<version>\_<arch>.zip}. The \emph{<name>} here is same name as in the third component of the provider URL, \verb'<version>' is the provider version, following a semantic versioning schema~\autocite{preston-werner_semantic_versioning_nodate} and \emph{<arch>} refers to the architecture and operating system for which the provider binary was compiled.

Although recommended, hosting the provider on a domain is strictly speaking not necessary. Alternatively it is possible to keep the zipped binary in a local directory and configure that directory as a \verb'filesystem_mirror'. The process and possibilities are described in~\autocite{noauthor_terraform_provider_installation_nodate} and the simplest one is to place the zipped binary in a directory that follows the three-component schema of the provider location underneath \verb'~/.terraform.d/plugins/', where \verb'~' is the users home directory. In our example, with version \emph{0.0.1} and on macOS this would look like:

\begin{lstlisting}
/Users/<youruser>/.terraform.d/
|-- checkpoint_cache
|-- checkpoint_signature
|-- plugins
    |-- example.com
        |-- tfp-example
            |-- example
            |-- terraform-provider-example\_0.0.1\_darwin\_arm64.zip
\end{lstlisting}

The \verb'<arch>' depends on the platform where the provider is compiled and used. A simple trick is to use the \verb'go' tool itself to determine the architecture and OS, since it outputs these values as needed, i.e.\ in a shell:

\begin{lstlisting}[language=bash,basicstyle=\ttfamily\footnotesize,numbers=none]
go version | cut -d' ' -f4 | sed -E 's/\//_/'
\end{lstlisting}

For our example this trick is part of the \verb'install' target in the \href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/tfp-example/Makefile}{\emph{Makefile}}, which serves the build and install cycle. The easiest way to install our example provider is to clone the example repository~\autocite{ecky-l_terraform-provider-example_nodate}, then change to the \verb'src/tfp-example/' directory and type \verb'make install' (\emph{Go} must be installed as a precondition).

\subsubsection{Provider Usage and the terraform Lifecycle}
\label{subsubsec:prov-usage-terr}

Once the provider is installed, it can be used. This is done in the two probably most executed terraform commands, which are executed in a terraform main module:

\begin{description}
\item[terraform plan] compares the current known terraform state with the resource definitions in the \verb'.tf' files. If there are differences, an output is generated that exactly specifies what terraform is going to do in case of \emph{apply}.
\item[terraform apply] actually executes the changes that were determined in the \emph{plan}. Before that it outputs the changes in the same manner as with \emph{plan} and usually asks for confirmation (which can be suppressed with the \verb'--auto-approve' flag).
\item[terraform destroy] deletes the resources from the backend and terraform state. This must also be confirmed.
\end{description}

To see this in action for our example, clone the example repository~\autocite{ecky-l_terraform-provider-example_nodate}, if you haven't done so already and start \emph{wiremock} as in Section~\ref{sec:simple-rest-api} with the shop article mappings from the directory \verb'src/wiremock/'. Then change to the directory \verb'src/exampletf/' and execute the commands. The \verb'terraform plan' should give the output in listing~\ref{lst:exampletfPlan}.

\begin{lstlisting}[label=lst:exampletfPlan]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # example_shop_article.example will be created
  + resource "example_shop_article" "example" {
      + description = "Child Shampoo & Conditioner"
      + id          = (known after apply)
      + name        = "Princess Rosalea"
    }

Plan: 1 to add, 0 to change, 0 to destroy.

-----------------------------------------------------------------------------------------
Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if you run "terraform apply" now.

\end{lstlisting}

A subsequent \verb'terraform apply' should result in the same output as in listing~\ref{lst:exampletfPlan}, plus an additional confirmation inquiry that must be answered literally with ``yes''. If you do this and subsequently execute \verb'terraform plan' again, the output in listing~\ref{lst:exampletfPlanInSync} indicates that the terraform state, the resource definitions in the \verb'.tf' files and the actual resources in the backend are in sync.

\begin{lstlisting}[label=lst:exampletfPlanInSync]
example_shop_article.example: Refreshing state... [name=Princess Rosalea]

No changes. Your infrastructure matches the configuration.

Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.
\end{lstlisting}

Now the resources in the module can be deleted by a \verb'terraform destroy', which displays the output in listing~\ref{lst:exampletfDestroy}. Entering ``yes'' at the prompt will delete the resource.

\begin{lstlisting}[label=lst:exampletfDestroy]
example_shop_article.example: Refreshing state... [name=Princess Rosalea]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  - destroy

Terraform will perform the following actions:

  # example_shop_article.example will be destroyed
  - resource "example_shop_article" "example" {
      - description = "Child Shampoo & Conditioner" -> null
      - id          = 1 -> null
      - name        = "Princess Rosalea" -> null
    }

Plan: 0 to add, 0 to change, 1 to destroy.

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value:
\end{lstlisting}

This ``terraform lifecycle'' is probably not new to most of you, as you have been coming here to learn about terraform provider development. But it is important to remember it during the development phase, as callbacks are executed at the different lifecycle stages and the sequence and matching of these executions must be well known. Hence this little reminder ;-).

\subsection{The Developer's View}
\label{subsec:developers-view}

From the perspective of a provider developer, things look a little different. Nevertheless he needs to see the practitioner's view as well and it is necessary that a plugin developer knows how terraform works, let alone to manually test his implementation. The most important resource during the course of provider development is the terraform framework documentation~\autocite{noauthor_terraform_framework_nodate}, where references and guidelines for provider development can be found. Here we will have a close look at a simple but self contained provider example. We start with an overview of the source and directory structure and then describe the source files themselves. The sources are not shown here in their entirety, but are referenced from the provider example repository~\autocite{ecky-l_terraform-provider-example_nodate}. Where appropriate, small peaces are shown here as listings.

\subsubsection{Sources Structure and Development Cycle}
\label{subsubsec:prov-sourc-struct}

Every software project has some kind of structure for source and auxiliary files inside a directory, that is set up once and then does not change much. For a terraform provider this does basically follow the conventions of a go module~\autocite{noauthor_go_modules_nodate} and in our example the structure can be found \href{https://github.com/ecky-l/terraform-provider-example/tree/main/src/tfp-example}{here} in the example repository~\autocite{ecky-l_terraform-provider-example_nodate}. It looks like listing~\ref{lst:directory-structure}. The module is initialized with the command \verb'go mod init terraform-provider-<name>', with \emph{<name>} being the provider name. A sub module of directory \emph{<name>} contains the provider specific sources, here inside the \verb'example/' directory. The files \verb'go.mod' and \verb'go.sum' are managed by the \verb'go' tool and contain module dependencies and their check sums.

\begin{lstlisting}[label=lst:directory-structure]
tfp-example
|-- docs
|   |-- index.md
|-- example
|   |-- provider_test.go
|   |-- provider.go
|   |-- shop_article_resource_test.go
|   |-- shop_article_resource.go
|-- go.mod
|-- go.sum
|-- main.go
|-- Makefile
\end{lstlisting}

The special file \verb'main.go' contains the entry point for the provider. A \verb'main()' function inside it starts the provider server, with which the \verb'terraform' tool communicates during runtime via \emph{Remote Procedure Calls} (\emph{RPC}):

\begin{lstlisting}[label=lst:main]
func main() {
    providerserver.Serve(context.Background(), example.New, providerserver.ServeOpts{
        Address: "example.com/tfp-example/example",
    })
}
\end{lstlisting}

During the development cycle it is frequently necessary to compile, test and install the latest binary. We use a \emph{Makefile} to ease the burden of these frequent cycles, which takes care of compressing and installing the binary in the directory mentioned in Section~\ref{subsubsec:prov-inst}. To do this, you can just type \verb'make install' inside the \verb'tfp-example' directory.

\subsubsection{The Provider and its Configuration}
\label{subsubsec:base-prov-conf}

Most providers do usually communicate with some kind of backend and must be configured appropriately to perform this functionality. From the practitioner's point of view (see Section~\ref{subsec:practitioners-view}) this is done with the \verb'provider' block. For a particular provider this block contains all configurable parameters and their values. From the provider developers point of view, the provider looks like the \verb'example/provider.go' file and it contains a few specific implementations.

A provider in the developers view is a structure that implements various methods from the terraform plugin framework~\autocite{noauthor_terraform_framework_nodate}. In our case this is the \verb'exampleProvider' struct:

\begin{lstlisting}
type exampleProvider struct {
	host string
}
\end{lstlisting}

This struct is passed as a receiver to the implementing methods in \verb'provider.go'. A concrete value is created with the \verb'New()' function, which in turn is passed to the \verb'providerserver.Serve()' method in listing~\ref{lst:main} and must therefore return a \verb'provider.Provider' interface type that implicitly implements all the methods for that interface. For this reason the go compiler enforces the implementation of all the necessary methods, which can be seen in \verb'provider.go'.

\begin{description}
\item[Metadata()] returns the provider name.
\item[Schema()] specifies and returns the parameters that can be configured in the \verb'provider' block for the resource (see listing~\ref{lst:example.tf}).
\item[Configure()] is called when a \verb'provider' block occurs in the \verb'.tf' sources and must take care of reading, validating and storing the values for the configurable parameters. In our example there is only one parameter \emph{host}. We check whether it is a valid URL and store it in the \verb'host' field in the provider struct receiver. Typically the configured values must be passed to the provider's resources later on, and this is done via fields in the \verb'provider.ConfigureResponse' pointer argument that is passed to \verb'Configure()'. We will see later, how values are retrieved during resource or data source configuration.
\item[DataSources()] returns a list of functions that create the \verb'data' source blocks, which are implemented by the provider.
  \item[Resources()] returns a list of functions that create the \verb'resource' blocks, which are implemented by the provider.
\end{description}

The return arguments of the latter two methods must be lists of functions, which create \verb'datasource.DataSource' and \verb'resource.Resource' go interface types respectively. They specify methods which must be implemented for the respective \verb'data' and \verb'resource' blocks, and are called during the lifecycle of a terraform run.

\subsubsection{A Word on Testing}
\label{subsubsec:note-on-testing}

It is good practice to start the implementation of any functionality with a unit- or integration test. Not only enforces this that we need to think about the design and implementation details itself - it also helps to test the implementation right from the beginning, by debugging from the test into the logic, and to mitigate regressions later on when the project evolves. The terraform SDK provides a testing framework~\autocite{noauthor_terraform_acceptance_testing_nodate}, which can be utilized in a comfortable manner to test all aspects in the lifecycle of a terraform run. At its core there is a call to \verb'resource.Test' or \verb'resource.UnitTest' inside an ordinary Go test with a \verb'resource.TestCase' as argument. This test case contains a list of steps that are executed in order with an internally maintained ephemeral state. The sequence of the test steps would closely resemble how a practitioner runs terraform on his infrastructure and \emph{tfstate} in the course of time: first he creates resources, then eventually updates these resources and then at some point later he deletes the resources again. In a terraform framework \verb'resource.TestCase' the deletion is done automatically as a last implicit step. Another optional step is to import existing resources by ID into the terraform state, which can also be covered.

A unit test for our resource, which is described in Section~\ref{subsec:emphsh-reso}, can be found \href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/tfp-example/example/shop_article_resource_test.go}{here}. It defines two steps in one test case, which create and update a \emph{shop\_article} resource, and implicitly delete it afterwards. At each step there are checks defined, which verify that the corresponding resource parameters have been set correctly. If you set up such a test right from the beginning when developing a resource, you can put break points inside the callback functions that are called during the test run and step into these callback functions to get their implementation right. Modern \emph{Integrated Development Environments} (\emph{IDE}s) allow you to run and debug tests directly on click with changed sources. This is much simpler than building and installing the provider each time, and then running terraform from the command line to identify bugs solely by log messages, or trial \& error.

There are two ways to test the code. A \verb'resource.UnitTest' is always executed when \verb'go test' is called. Care must be taken when the code communicates with an actual backend: then the resources are indeed created in this backend, which might not be what you want. Therefore there is a second function \verb'resource.Test', which is only executed when the environment variable \verb'TF_ACC' is set. Although the difference is small, it is good practice to use unit tests with mocked backends, where no actual resources are created, and acceptance tests with real backends, when the real integration with the terraform provider is to be verified. For mocked backends there are several strategies. One is to use tools like \emph{Wiremock}~\autocite{noauthor_wiremock_nodate}, that pretend to be a backend but just return artificial responses. Another is to use a mock implementation of the backend calling library type, i.e. \verb'http.Client', and a mocking framework, i.e. \emph{testify/mock}~\autocite{noauthor_testifymock_nodate}, to specify exact responses for certain calls on the mock. \verb'Go''s implicit interface implementation can help to create mocks for any, even library types that are outside the developer's control.

Although the second option is appealing, as it does not require any other tools and processes to be run, we follow the first approach and use \emph{Wiremock} in this example. The advantage is it's simplicity - responses can just be defined by JSON files in the \verb'mappings/' directory (see Section~\ref{sec:simple-rest-api}). At a downside, \verb'wiremock' must always be started in the background and listen for connections when tests are run, and it must be in the correct state.

\subsubsection{The \emph{shop\_article} Terraform Resource}
\label{subsec:emphsh-reso}

For our example we implement one resource with the name \emph{example\_shop\_article}. The corresponding implementation is in \href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/tfp-example/example/shop_article_resource.go}{this file} in the example repository~\autocite{ecky-l_terraform-provider-example_nodate}. In this section will see a short description of this file.

As with the provider itself, each resource is represented by a \emph{struct} and can contain arbitrary data. For our example the resources struct looks like the one in listing~\ref{lst:shopArticleResource}.

\begin{lstlisting}[label=lst:shopArticleResource]
type shopArticleResource struct {
	provider *exampleProvider
}
\end{lstlisting}

Its only field is a pointer to the provider struct value, to which it belongs. This field is filled during the terraform lifecycle in the \verb'Configure()' method of the resource struct as described below. Another struct, in our example called \verb'shopArticleResourceModel', represents a concrete resource of that type with corresponding values. This struct is instantiated for each concrete resource of the resource type and passed from and to the terraform provider \verb'request' and \verb'response' arguments in the callbacks. It serves for two things:

\begin{description}
\item[The \emph{plan}] is the desired resources state when the terraform lifecycle is finished. It is determined from the \verb'.tf' files in a terraform module and contains the parameters for the resource ``to be''.
\item[The \emph{state}] is the resource that \emph{exists} in the terraform state due to prior creation or modification. An empty state is created for a resource that not (yet) exists.
\end{description}

When a \verb'terraform plan' is executed by the practitioner, the plan and state values for each resource are compared and divergences are determined. If no divergences exist, the terraform lifecycle finishes with an appropriate message. Otherwise terraform shows what needs to be done to bring the state in sync with the plan for that resource. In our example the resource model struct is shown in listing~\ref{lst:shopArticleResourceModel}.

\begin{lstlisting}[label=lst:shopArticleResourceModel]
type shopArticleResourceModel struct {
	ID          types.Int64  `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
}
\end{lstlisting}

The \verb'`tfsdk:*`' directives after each field indicate which parameters in the \emph{resource schema} are to be used for the field value. They ensure that the values in a resource definition, like the one in listing~\ref{lst:example.tf}, are put into the fields of the \emph{plan} for that resource.

A function that returns an instance of the struct must be listed in the return value of the \verb'Resources()' method of the provider (see Section~\ref{subsubsec:base-prov-conf}) in order to actually hook the resource in. This enforces that the resource's struct implements a set of methods, namely:

\begin{description}
\item[Metadata()] is called by terraform to determine meta data of the resource block. Most notably it registers the name of the resource, such that a resource definition like in listing~\ref{lst:example.tf} is possible.
\item[Configure()] is called when terraform encounters a \verb'resource' block of the respective type. In this callback it is possible to pass provider parameters to the resource struct. In our example resource we set a pointer to the provider struct into the resource, by which we can later refer to the backend host. More parameters are possible as needed.
\item[Schema()] is called to determine which parameters are possible for the resource. It returns a defined \verb'schema.Schema' value with the possible parameters of the resource and its constraints. In our example, note the \verb'PlanModifiers' setting. By specifying the \verb'RequiresReplace' plan modifier, the resource would be deleted and re-created if the practitioner changes its name. Other such plan modifiers are possible and can even be self-implemented.
\item[Create()] is called when terraform determines that a declared resource must be created. This callback must implement the creation of the entity in the backend. In our case we issue a \verb'POST' call to our web service to create a shop article. Afterwards the parameters of the newly created resource must be set to the state model and the state must be updated in the \emph{response} argument of the callback.
\item[Delete()] is called when terraform determines that a resource must be deleted. This is the case either when \verb'terraform destroy' has been called or the resource declaration is not present anymore in the terraform module. The callback must implement the deletion of the resource in the backend, in our case we issue a \verb'DELETE' request to our web service.
\item[Read()] is called when terraform needs to determine the backend state of a declared resource. This is the case either when the resource is to be imported, or in order to synchronize the terraform state with the backend state. When talking to a REST web service, the callback does usually implement a \verb'GET' call to retrieve the backing entity of the resource, i.e.\ by ID.\ We call \verb'GET /articles/<id>' to retrieve the shop article from the web service and update the state values in the \emph{response} argument of the callback.
  \item[Update()] is called when the terraform \emph{plan} (the resource value that has been determined from the \verb'.tf' files) diverges from the terraform \emph{state}. In this case the backend entity must eventually be updated and the callback must implement the corresponding logic. In our example we determine the plan's new description value and send a \verb'PUT' call with an appropriate JSON payload to our backend to update the entity.
\end{description}

The methods do closely interact with their arguments. As you can see, the \verb'response' arguments are pointers to various types inside the terraform provider framework. The intend behind this is that values inside the response are meant to be updated by the callback, for instance should the resource state with updated values be set into the response.

\paragraph{Error Handling}

The response argument to the callbacks does also contain a field called \verb'Diagnostics'. It serves as a storage for information that is formatted and displayed to the practitioner during the terraform lifecycle and is particularly useful for error messages. Therefore the error handling is done frequently by a call to \verb'response.Diagnostics.AddError()', like in listing~\ref{lst:errorHandling} for JSON unmarshalling.

\begin{lstlisting}[label=lst:errorHandling]
if err := dec.Decode(&respBody); err != nil {
    resp.Diagnostics.AddError("Error during article Create", fmt.Sprintf("Json unmarshalling error: %v", err))
    return
}
\end{lstlisting}

If the caught error occures, the practitioner would see the appropriate message:

\begin{lstlisting}
...
example_shop_article.example: Creating...
|
| Error: Error during article Create
|
|   with example_shop_article.example,
|   on main.tf line 14, in resource "example_shop_article" "example":
|   14: resource "example_shop_article" "example" {
|
| Json unmarshalling error: unexpected EOF
|
\end{lstlisting}

The callback implementations for our example are quite simple. Normally one would encapsulate the backend calls in a helper function or object, instead of repeating the code in every callback function, and also do more advanced error handling. But for demonstration purposes it is just fine to have it that direct way.

\section{Summary}
\label{sec:summary}

Sometimes it is necessary to maintain infrastructure as code with terraform for resources, which are not supported out of the box - be it because they are self-developed, or for other reasons. Terraform has a powerful plugin mechanism and well documented SDK, that enables the development of own in-house providers for such cases.

In this article we have introduced the terraform provider framework by using a small, self contained and illustrative example. A terraform provider ``example'' is developed with one resource \emph{shop\_article} that is backed by an artificial REST backend, provided by a \emph{Wiremock scenario}. We have seen how the overall code can be structured, how development versions of a provider can be installed, used and tested, including tips and best practices to use the terraform testing framework.

A accompanying \emph{DataSource} for the \emph{shop\_article} entity is not part of this example. But this is not very complicated after following this article and looking at the sources, so it is left for encouraged readers as an exercise.

\printbibliography[heading=bibintoc]

\end{document}
