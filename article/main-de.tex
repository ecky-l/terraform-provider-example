\documentclass[paper=a4,11pt,numbers=noenddot]{article}
\linespread{1.2}
\usepackage[parfill]{parskip} % non-indented paragraphs with more space
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage[pdftex]{color,graphicx}

\usepackage[autocite=plain, backend=biber, style=numeric, sorting=nyt]{biblatex}
%\addbibresource{main.bib} % The filename of the bibliography
\bibliography{main}
\nocite{*}

\usepackage{listings}
\renewcommand{\lstlistlistingname}{List of Listings}
\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\scriptsize,
  numbers=none,
  backgroundcolor=\color[rgb]{0.95,0.90,0.90},
  commentstyle=\color[rgb]{0,0.6,0},
  keywordstyle=\color[rgb]{0.2,0.6,1},
  breakatwhitespace=false,
  breaklines=true,
%  captionpos=b,
  keepspaces=true,
%  numbers=left,
%  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mystyle}
\usepackage{upquote} % for backticks display in listings

\usepackage[plainpages=false,pdfpagelabels,hidelinks]{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=blue,
}
\urlstyle{same}

%% margins
\oddsidemargin 0cm
\evensidemargin 0cm
\textwidth 16cm
\topmargin 0cm
%\textheight 24.37cm

\title{Terraform Provider Development}
\author{Eckhard Lehmann}

\begin{document}
\maketitle
\tableofcontents

\section{Einleitung}

Hier bei Otto arbeiten wir mit vielen verschiedenen IT-Systemen, z.B. für den Online-Shop, um Bestellungen und Lieferungen zu verarbeiten oder um Kundendaten zu verwalten. Viele davon sind selbst entwickelt und die Services werden verteilt auf on-premise- und cloud Infrastruktur gehostet. Die Zeit für Release- und Deploymentzyklen spielt eine große Rolle, genau wie die Nachvollziehbarkeit von Änderungen. Daher verwenden die meisten Teams sofern möglich \emph{Infrastructure as Code} (\emph{IaC})~\autocite{morris_infrastructure_as_code_2025} und deklaratives Konfigurationsmanagement. In meinem Team werden die meisten Deployments und Infrastrukturänderungen per Terraform~\autocite{noauthor_terraform_nodate} gemacht und die meisten Anwendungsfälle werden durch das existierende Terraform-Ökosystem abgedeckt.

Aber manchmal ist das nicht der Fall. Wir entwickeln und betreiben einen Service zur Verwaltung von Berechtigungen für Topics in dem asynchronen Messaging-System \emph{Apache Kafka} in der \emph{Confluent Cloud}~\autocite{noauthor_apache_kafka_nodate, noauthor_confluent_nodate}. Die Benutzer sind andere Entwicklungsteams in der Firma, die Kafka zum Austausch von Daten und Nachrichten in ihren jeweiligen Systemen benutzen. Sie benutzen größtenteils ebenfalls Terraform für die Deployments dieser Systeme und es bietet sich an, auch die Entitäten in unserem Service damit zu verwalten. Ein offizieller Provider für unser In-House System ist natürlich nicht verfügbar und so haben wir die Gelegenheit einen solchen zu entwickeln.

In diesem Artikel präsentiere ich unsere Erfahrungen mit der Entwicklung von Terraform-Providern anhand eines kleinen, künstlichen Beispiels. Es enthält die extrahierten Erfahrungsschätze unserer In-House Provider-Entwicklung in einer leicht verständlichen Form und ohne In-House Wissen. Abschnitt~\ref{sec:technology-overview} gibt einen kurzen Überblick über die benutzten und notwendigen Technologien. Abschnitt~\ref{sec:simple-rest-api} zeigt die Atrappe einer API, die als ``Backend'' für den Beispiel-Provider benutzt wird und in Abschnitt~\ref{sec:creat-terr-prov} wird der Beispiel-Provider selbst aus zwei Perspektiven vorgestellt. Die Ergebnisse werden letztendlich in Abschnitt~\ref{sec:summary} zusammengefasst. Da der gesamte Text eng verbunden ist mit dem \emph{terraform-provider-example} Github Repository~\autocite{ecky-l_terraform-provider-example_nodate}, bietet es sich an, dieses Repository zu klonen und nebenbei einen Blick darauf zu werfen.

\section{Technologie-Überblick}
\label{sec:technology-overview}

Wie bei den meisten heutigen Aufgaben in der Softwareentwicklung gibt es schon Technologien, Tools und Frameworks, auf die man aufbauen kann. Terraform selber ist in \emph{Go} programmiert und der einfachste Weg ist, \emph{Go} auch für die Provider-Entwicklung zu nutzen\footnote{Terraform kommuniziert mit Providern über RPC, demnach wäre es prinzipiell möglich, jede Programmiersprache zu nutzen, die auch RPC kann, aber ein High-Level SDK gibt es nur für \emph{Go}}. Deshalb enthält dieser Abschnitt eine kurze Einführung in \emph{Go} und das Terraform Ökosystem.

\subsection{Die Programmiersprache Go}
\label{subsec:go-progr-lang}

Go, oder ``golang'' ist eine moderne, allgemeine Programmiersprache und wurde bei Google entwickelt. Sie ist statisch typisiert und wird mit entsprechenden Typenprüfungen vor der Ausführung in Binärcode kompiliert. Dadurch wird schon vor der Ausführung des Programms eine ganze Klasse von Fehlern ausgeschlossen, die mit dynamisch typisierten und interpretierten Programmiersprachen auftreten können. Golang hat seine Wurzeln in C, Pascal/Oberon und Programmiersprachen mit dem \emph{CSP} (\emph{Communicating Sequential Processes}) Konzept, wie Squeak und Alef~\autocite{donovan_go_2016}. Von diesen Sprachen kommt ein interressantes Modell für die Verwaltung konkurrierender Zugriffe, wodurch Go gerade für parallele Programmierung interessant ist.

Die prominenteste und am besten sichtbare Abstammung hat Go von der Programmiersprache \emph{C}, weswegen sie auch als \emph{C des 21. Jahrhunderts} bezeichnet wird. Allerdings ist die Ähnlichkeit nur oberflächlich, unter der Haube hat Go Garbage Collection, Objektorientierung, Speichersicherheit, typensichere Zeiger und Referenzen sowie funktionale Elemente. Außerdem umfasst Go in dem Kommando \verb'go' selbst ein modernes Toolset für Abhängigkeitsverwaltung, Tests, Dokumentations-Erzeugung, Linting und Profiling - kurzum für alle Dinge, die man in der täglichen Nutzung braucht.

Die Webseite \url{https://go.dev/} ist der zentrale Einstiegspunkt für alle Resourcen rund um Golang, inklusive des sehenswerten Tutorials \emph{Tour of Go}. Für die Entwicklung von Terraform Providern lohnt es sich, dieses Tutorial anzuschauen und mit Golang vertraut zu werden, sofern nicht schon geschehen.

\subsection{\emph{Terraform} und sein Ökosystem}
\label{subsec:terr-tool-ecosyst}

Terraform ist ein Werkzeug zur Verwaltung von Infrastructure as Code. Als zentrales Konzept dient der sogenannte \emph{Terraform-State}, eine JSON-Datei mit einer spezifischen Struktur, die den aktuellen Zustand einer bestimmten Infrastruktur in Form ihrer Ressourcen beschreibt. Zusätzlich gibt es eine Sammlung von Ressourcendefinitionen in \verb'.tf'-Dateien innerhalb eines Verzeichnisses, das als \emph{Terraform-Modul} bezeichnet wird.
Um ein solches Modul zu erstellen, werden Dateien mit der Endung \verb'.tf' mit Ressourcendefinitionen in einem Verzeichnis abgelegt.
Als einfaches Beispiel betrachten wir eine Ressourcen-Entität ``Shop-Artikel'' mit bestimmten Attributen:

\begin{lstlisting}
resource "shop_article" "shampoo" {
  name        = "Princess Rosalea"
  description = "Child Shampoo & Conditioner"
}
\end{lstlisting}

In der Realität handelt es sich dabei um Computerressourcen wie Netzwerke, Datenbanken, virtuelle Maschineninstanzen usw.. Terraform-Ressourcen werden verwendet, um Computerinfrastruktur in Cloud-Umgebungen zu beschreiben. Daher ist immer ein Backend beteiligt –in der Regel eine REST-API–, in dem die Logik implementiert ist, um die jeweiligen Ressourcen in der Cloud-Umgebung bereitzustellen.

Der Befehl \verb'terraform' wird verwendet, um die \verb'.tf'-Dateien in einem Verzeichnis einzulesen, die notwendigen Aktionen zum Erstellen der Ressourcen auszuführen (d.h.\ die API-Endpunkte aufzurufen) und den Zustand im Terraform-State zu speichern. Standardmäßig ist dies eine lokale JSON-Datei mit dem Namen \verb'terraform.tfstate'. In der Regel wird das Modul jedoch so konfiguriert, dass der State an einem entfernten Ort gespeichert wird, z.B. in einem Cloud-Speicher-Bucket oder in einer Datenbank. Wann immer Ressourcen erstellt, geändert oder gelöscht werden sollen, genügt es, die entsprechenden Ressourcendefinitionen in den \verb'.tf'-Dateien zu bearbeiten und \verb'terraform' erneut auszuführen. Ein \verb'terraform apply' tut dann drei Dinge:

\begin{enumerate}
\item\label{itm:tf-read} Die aktuellen Ressourcen im Backend abrufen.
\item\label{itm:tf-compare} Einen Drei-Wege-Vergleich zwischen dem aktuellen Status, den abgerufenen realen Ressourcen und den Ressourcendateien (\verb'.tf') durchführen, und anschließend:
  \begin{itemize}
  \item Ressourcen löschen, die im Backend vorhanden sind, aber nicht in den Ressourcendateien definiert sind.
  \item Ressourcen erstellen, die in den Ressourcendateien definiert sind, aber im Backend noch nicht existieren.
  \item Ressourcen anpassen, deren Definition sich in den Ressourcendateien im Vergleich zur vorherigen Definition im Status geändert hat.
  \end{itemize}
\item\label{itm:tf-create-update} Den neuen Status in der Statusdatei speichern.
\end{enumerate}

Terraform stellt seine Funktionalität über eine Kernkomponente bereit, die die \verb'.tf'-Dateien einliest und den Status verwaltet, sowie über eine Reihe von Plugins, die mit verschiedenen Backends interagieren. Diese Plugins werden Provider genannt und stellen die eigentliche Funktionalität des Infrastrukturanagements bereit. Sie sind vom Terraform-Kern entkoppelt und entwickeln sich unabhängig weiter. Provider existieren für alle bekannten Cloud-Anbieter sowie für verschiedene andere Infrastruktur-Dienste, wie zum Beispiel die IAM-Lösung Keycloak~\autocite{team_keycloak_nodate} oder den Secret Manager Vault~\autocite{noauthor_vault_nodate}.

Ein Einstiegspunkt zur Suche nach Terraform-Providern und deren Dokumentation ist die Terraform Provider Registry~\autocite{noauthor_terraform_registry_nodate}. Es gibt zahlreiche Ressourcen zu Terraform, wobei die Hauptanlaufstelle die offizielle Homepage ist~\autocite{noauthor_terraform_nodate}. Eine gute Einführung mit praktischen Beispielen findet sich außerdem in~\autocite{brikman_terraform_2022}.

\section{Ein einfaches REST API Backend}
\label{sec:simple-rest-api}

Der Zweck von Terraform besteht darin, Infrastruktur als Code zu verwalten, d.h. Infrastruktur-Ressourcen zu erstellen, zu ändern und zu löschen. Wie genau diese Ressourcen aussehen, ist nicht streng festgelegt und obliegt der Implementierung des jeweiligen Providers. Bei einem Cloud-Anbieter wie AWS oder GCP können es virtuelle Hardware-Ressourcen oder Firewall- und Berechtigungsregeln sein, während es bei einer Keycloak-Instanz OpenID-Connect-Clients und entsprechende Zugangsdaten sein könnten. Auf einer lokalen Maschine könnten es Dateien im Dateisystem, Dienstverwaltungs-Skripte oder Richtlinien für Mandatory Access Control (z. B. für SELinux) sein.

Um die Dinge einfach zu halten, betrachten wir für diese Demonstration ein einfaches REST-API-Backend, bei dem die Ressourcen Shop-Artikel sind. Darüber hinaus werden wir dieses Backend gar nicht wirklich erstellen, sondern stattdessen nur simulieren. Wiremock~\autocite{noauthor_wiremock_nodate} ist ein leistungsfähiges Tool und eine Bibliothek, deren einziger Zweck es ist, bestimmte Antworten basierend auf bestimmten Eingabemustern zurückzugeben. Normalerweise wird es verwendet, um API-Clients in verschiedenen Programmiersprachen zu testen, wenn das echte API-Backend noch nicht verfügbar ist oder nicht für Tests benutzt werden soll.

\paragraph{Die REST-Ressource \emph{article}}

Unsere REST-API verwaltet eine Ressource namens \emph{article}, die im Wesentlichen einen Online-Shop-Artikel darstellt. Sie enthält eine ID, einen Namen und eine Beschreibung. Artikel können erstellt, über ihre ID abgerufen, aktualisiert und gelöscht werden. Obwohl dies stark vereinfacht ist, reicht es für ein anschauliches Beispiel.

Die Verwaltung unserer REST-Ressource kann als Zustandsmaschine beschrieben werden: Anfangs existiert kein Artikel, also liefert ein \verb'GET'-Aufruf zu einer bestimmten ID, z.B. \emph{1}, den HTTP-Status 404. Dies entspricht dem Zustand $S_0$, oder \emph{Started}. Wenn ein \verb'POST'-Aufruf an den Endpunkt \verb'/articles' erfolgt, wird ein Artikel mit einer bestimmten ID, z.B. \emph{1}, erstellt, und der Zustand der Entität wechselt zu $S_1$, oder \emph{Article added}. Ein \verb'GET'-Aufruf zu \verb'/articles/1' im Zustand $S_1$ liefert den erstellten Artikel zurück.

Nun gibt es zwei Möglichkeiten, den Zustand erneut zu ändern: Ein \verb'PUT'-Aufruf zu \verb'/articles/1' verändert den Artikel und setzt den Zustand auf $S_2$, oder \emph{Article modified}. Nachfolgende \verb'GET'-Aufrufe zu \verb'/articles/1' liefern nun den geänderten Artikel. Ein \verb'DELETE'-Aufruf zu \verb'/articles/1' ``löscht'' den Artikel sowohl in $S_1$ als auch in $S_2$ und setzt den Zustand wieder auf $S_0$ zurück. Weitere Modifikationen oder spezifische Erstellungs-/Aktualisierungsparameter werden hier nicht berücksichtigt.

In Wiremock kann dies als \emph{Scenario} dargestellt werden~\autocite{noauthor_wiremock_stateful_behavior_2025}. Unser Artikel ist ein Kindershampoo, und die entsprechende Datei findet sich~\href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/wiremock/mappings/shampoo.json}{hier} im GitHub-Repository dieses Beispiels~\autocite{ecky-l_terraform-provider-example_nodate}.

Erstellen Sie ein Verzeichnis namens mappings und legen Sie die Datei dort ab. Laden Sie anschließend die Standalone-Binärdatei von der Wiremock-Homepage herunter, platzieren Sie sie neben dem mappings-Verzeichnis und starten Sie Wiremock mit dem Befehl \verb'java -jar wiremock-standalone-<version>.jar'. Sie sollten sehen, dass der Dienst startet und auf Port \verb'8080' lauscht. Anschließend können Sie überprüfen, ob unser neues ``API-Backend'' funktioniert:

\begin{lstlisting}[language=bash]
$ curl -s localhost:8080/articles/1 | jq
{
  "error": "not found"
}
$ curl -sX POST localhost:8080/articles | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner"
}
$ curl -s localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner."
}
$ curl -sX PUT localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner. Soft on the skin, soft on the environment."
}
$ curl -s localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner. Soft on the skin, soft on the environment."
}
$ curl -X DELETE localhost:8080/articles/1
$ curl -s localhost:8080/articles/1 | jq
{
  "error": "not found"
}
\end{lstlisting}

Das ist alles was wir brauchen, um die \emph{shop\_article} Resource im Backend darzustellen, die wir in den folgenden Abschnitten brauchen werden.

\section{Entwicklung eines Terraform Provider mit einer Ressource}
\label{sec:creat-terr-prov}

Die Kommunikation zwischen dem Terraform Kern und den Providern funktioniert über eine RPC-Schnittstelle und Callback-Funktionen, die an bestimmten Stellen in der Interaktion der Punkte~\ref{itm:tf-read}-~\ref{itm:tf-create-update} in Abschnitt~\ref{subsec:terr-tool-ecosyst} ausgeführt werden. Diese Interaktionen, die man auch als den ``Terraform Lebenszyklus'' bezeichnen könnte, lassen sich aus zwei Perspektiven betrachten: aus der des Benutzers (in der Dokumentation auch als ``Practitioner'' bezeichnet) und der des Provider-Entwicklers. Im Folgenden werden beide Perspektiven betrachtet, angefangen mit der des Terraform-Benutzers.


Communication between the terraform core and the providers is implemented via an RPC interface and callback functions that are executed at specific points in the interaction~\ref{itm:tf-read}-~\ref{itm:tf-create-update} in Section~\ref{subsec:terr-tool-ecosyst}.

\subsection{Die Perspektive des Anwenders}
\label{subsec:practitioners-view}

Als ``Practitioner'' wird in der Dokumentation des Terraform Plugin Frameworks~\autocite{noauthor_terraform_framework_nodate} häufig die Person bezeichnet, die Infrastruktur als Code in Terraform verwaltet. Er bzw.\ sie hat einen Satz von \verb'.tf'-Dateien in einem Verzeichnis, das ein Terraform-Modul bildet und nutzt die Ressourcen und Datenquellen, die ein Provider bereitstellt. Neben der Pflege dieser Dateien beschäftigt er sich auch mit der Installation und Aktualisierung von Providern, und sein Hauptanliegen ist, dass seine Infrastruktur dabei stabil bleibt. Eine gute Einführung zur Benutzung von Terraform, also der Perspektive des ``Practitioners'', bietet~\autocite{brikman_terraform_2022}. In diesem Abschnitt werden wir die Welt unseres Beispiel-Providers aus seiner Perspektive aussieht.

\subsubsection{Ein Beispiel-Terraform-Modul}
\label{subsubsec:an-example-terraform}

In unserem Beispiel gibt es ein Terraform-Modul (Verzeichnis) mit einer Datei \verb'main.tf'. Der Inhalt dieser Datei ist in Listing~\ref{lst:example.tf} zu sehen und kann~\href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/exampletf}{hier} im GitHub-Repository~\autocite{ecky-l_terraform-provider-example_nodate} gefunden werden.

\begin{lstlisting}[label=lst:example.tf]
terraform {
  required_providers {
    example = {
      source  = "example.com/tfp-example/example"
      version = "0.0.1"
  }
}

provider "example" {
  host = "http://localhost:8080"
}

resource "example_shop_article" "example" {
  name        = "Princess Rosalea"
  description = "Child Shampoo & Conditioner"
}
\end{lstlisting}

Jedes Terraform-Hauptmodul\footnote{Es gibt auch Untermodule, die nicht notwendigerweise alle Konfigurationsoptionen enthalten, wenn sie in anderen (Haupt-)Modulen verwendet werden.} enthält mindestens einen \verb'terraform'-Block, in dem die \emph{erforderlichen Provider} konfiguriert werden. Jeder Provider wird mit seinem Namen und der Quelle, von der er heruntergeladen werden kann, aufgeführt. Die erforderliche Version ist optional, anderenfalls wird automatisch die neueste Version ermittelt und verwendet. Anschließend folgt optional jeweils ein \verb'provider'-Block, in dem spezielle Konfigurationen übergeben werden können. Danach können die Ressourcen und Datenquellen des Providers verwendet werden.

Ein \verb'terraform init' im Verzeichnis mit den Terraform-Quellen lädt den Provider aus der angegebenen Quelle herunter und extrahiert ihn in das lokale \emph{.terraform}-Verzeichnis. Ein anschließendes \verb'terraform plan' zeigt an, was passieren wird, d.h.\ welche Ressourcen erstellt/modifiziert/gelöscht werden. Danach führt ein \verb'terraform apply' den Plan tatsächlich aus. Während dieser Befehle kommuniziert Terraform mit dem Provider und ruft eine Reihe von Funktionen auf, die im Folgenden beschrieben werden.

\subsubsection{Provider-Installation}
\label{subsubsec:prov-inst}

Der \verb'source'-Parameter im \verb'required_providers'-Block hat eine spezielle Struktur, die angibt, wo das Binär-Release des Providers zu finden ist. Er besteht aus drei Teilen:

\begin{itemize}
\item Der Domain, auf der sich das Provider-Release befindet.
\item Einem Namensraum für den Provider, meist ein Team oder Unternehmen, von dem der Provider kommt.
\item Dem Namen des Providers.
\end{itemize}

Daraus ergibt sich, dass die Quelle immer dem Schema \emph{<domain>/<namespace>/<provider name>} folgt. Die meisten Provider werden im Terraform Provider Registry~\autocite{noauthor_terraform_registry_nodate} gehostet, weshalb die Domain \emph{registry.terraform.io} für diese Provider der Einfachheit halber weggelassen werden kann. Andernfalls muss es sich um eine gültige Domain handeln, unter der ein Webserver die Provider-Binärdateien innerhalb der Verzeichnisstruktur \emph{<namespace>/<provider name>} bereitstellt. Dort müssen die Releases nach dem Schema \emph{terraform-provider-<name>\_<version>\_<arch>.zip} benannt sein. Das \emph{<name>} ist dabei derselbe Name wie in der dritten Komponente der Provider-URL, \verb'<version>' ist die Provider-Version nach semantischer Versionsnummerierung~\autocite{preston-werner_semantic_versioning_nodate} und \emph{<arch>} bezeichnet die Architektur und das Betriebssystem, für die der Provider kompiliert wurde.

Obwohl empfohlen, ist das Hosten des Providers auf einer Domain streng genommen nicht erforderlich. Alternativ kann die gezippte Binärdatei in einem lokalen Verzeichnis abgelegt und dieses als \verb'filesystem_mirror' konfiguriert werden. Der Prozess und die verschiedenen Möglichkeiten sind in~\autocite{noauthor_terraform_provider_installation_nodate} beschrieben. Die einfachste Variante besteht darin, die gezippte Binärdatei in ein Verzeichnis zu legen, das der dreiteiligen Schema-Struktur des Provider-Standorts unterhalb von \verb'~/.terraform.d/plugins/' folgt, wobei \verb'~' das Home-Verzeichnis des Benutzers ist. In unserem Beispiel mit der Version \emph{0.0.1} und unter macOS sieht dies folgendermaßen aus:

\begin{lstlisting}
/Users/<youruser>/.terraform.d/
|-- checkpoint_cache
|-- checkpoint_signature
|-- plugins
    |-- example.com
        |-- tfp-example
            |-- example
            |-- terraform-provider-example\_0.0.1\_darwin\_arm64.zip
\end{lstlisting}

Der Parameter \verb'<arch>' bezeichnet die Architektur der Plattform, für die der Provider kompiliert wurde. Um die aktuelle Architektur herauszufinden, kann man das \verb'go'-Tool selbst verwenden, da es die benötigten Werte für Architektur und Betriebssystem ausgibt. Dafür kann z.B.\ in einer Shell das folgende Kommando ausgeführt werden:

\begin{lstlisting}[language=bash,basicstyle=\ttfamily\footnotesize,numbers=none]
go version | cut -d' ' -f4 | sed -E 's/\//_/'
\end{lstlisting}

Dieser Trick ist in unserem Beispiel Teil des \verb'install'-Ziels im \href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/tfp-example/Makefile}{\emph{Makefile}} das den Build- und Installationszyklus steuert. Der einfachste Weg, unseren Beispiel-Provider zu installieren, besteht darin, im geklonten Beispiel-Repository~\autocite{ecky-l_terraform-provider-example_nodate} in das Verzeichnis \verb'src/tfp-example/' zu wechseln und \verb'make install' auszuführen (eine installierte \emph{Go}-Umgebung ist Voraussetzung).

\subsubsection{Verwendung des Providers und der ``Terraform-Lebenszyklus''}
\label{subsubsec:prov-usage-terr}

Sobald der Provider installiert ist, kann er verwendet werden. Dies geschieht in den beiden wahrscheinlich am häufigsten ausgeführten Terraform-Befehlen, die in einem Terraform-Hauptmodul ausgeführt werden:

\begin{description}
\item[\texttt{terraform plan}] vergleicht den aktuellen bekannten Terraform-State mit den Ressourcendefinitionen in den \verb'.tf'-Dateien. Wenn Unterschiede bestehen, wird eine Ausgabe erzeugt, die genau angibt, was Terraform im Falle eines \emph{apply} tun wird.
\item[\texttt{terraform apply}] führt die im \emph{plan} ermittelten Änderungen aus. Zuvor werden die Änderungen in derselben Form angezeigt, und es wird eine Bestätigung verlangt (die mit dem Flag \verb'--auto-approve' unterdrückt werden kann).
\item[\texttt{terraform destroy}] löscht die Ressourcen aus dem Backend und dem Terraform-State. Auch hier ist eine Bestätigung erforderlich.
\end{description}

Um dies in Aktion zu sehen, muss \emph{wiremock} im Verzeichnis \verb'src/wiremock/' gestartet werden. Das enthaltene \verb'mappings/'-Verzeichnis enthält das Szenario für den Shop-Artikel (vgl.\ Abschnitt~\ref{sec:simple-rest-api}). Im Verzeichnis \verb'src/exampletf/' können dann die o.g.\ Terraform-Befehle ausgeführt werden. Ein \verb'terraform plan' sollte die Ausgabe aus Listing~\ref{lst:exampletfPlan} liefern.

\begin{lstlisting}[label=lst:exampletfPlan]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # example_shop_article.example will be created
  + resource "example_shop_article" "example" {
      + description = "Child Shampoo & Conditioner"
      + id          = (known after apply)
      + name        = "Princess Rosalea"
    }

Plan: 1 to add, 0 to change, 0 to destroy.

-----------------------------------------------------------------------------------------
Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if you run "terraform apply" now.

\end{lstlisting}

Ein anschließendes \verb'terraform apply' sollte dasselbe Ergebnis wie in Listing~\ref{lst:exampletfPlan} zeigen, ergänzt um eine zusätzliche Bestätigungsabfrage, die wortwörtlich mit ``yes'' beantwortet werden muss. Nachdem das erfolgt ist, zeigt ein anschließendes \verb'terraform plan' mit der Ausgabe in Listing~\ref{lst:exampletfPlanInSync}, dass der Terraform-State, die Ressourcendefinitionen in den \verb'.tf'-Dateien und die tatsächlichen Ressourcen im Backend synchron sind.

\begin{lstlisting}[label=lst:exampletfPlanInSync]
example_shop_article.example: Refreshing state... [name=Princess Rosalea]

No changes. Your infrastructure matches the configuration.

Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.
\end{lstlisting}

Nun können die Ressourcen im Modul mit einem \verb'terraform destroy' gelöscht werden, wobei die Ausgabe in Listing~\ref{lst:exampletfDestroy} gezeigt wird. Mit der wortwörtlichen Eingabe von ``yes'' werden die Ressourcen gelöscht.

\begin{lstlisting}[label=lst:exampletfDestroy]
example_shop_article.example: Refreshing state... [name=Princess Rosalea]

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  - destroy

Terraform will perform the following actions:

  # example_shop_article.example will be destroyed
  - resource "example_shop_article" "example" {
      - description = "Child Shampoo & Conditioner" -> null
      - id          = 1 -> null
      - name        = "Princess Rosalea" -> null
    }

Plan: 0 to add, 0 to change, 1 to destroy.

Do you really want to destroy all resources?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value:
\end{lstlisting}

Dieser ``Terraform-Lebenszyklus'' ist den meisten Lesern wahrscheinlich bekannt, da sie ihren Weg hierher gefunden haben, um mehr über die Entwicklung von Terraform-Providern zu lernen. Dennoch ist es wichtig, ihn sich während der Entwicklungsphase ins Gedächtnis zu rufen, um die Reihenfolge und Zuordnung der Callbacks in den verschiedenen Phasen herstellen zu können. Daher diese kleine Wiederholung ;-).

\subsection{Die Entwickler-Perspektive}
\label{subsec:developers-view}

Aus der Perspektive eines Provider-Entwicklers sieht die Welt ein wenig anders aus. Dennoch muss er auch die Sichtweise desder Praktikerin verstehen, und es ist notwendig, dass ein Plugin-Entwickler weiß, wie Terraform funktioniert – nicht zuletzt, um seine Implementierung manuell zu testen. Die wichtigste Ressource während der Entwicklung eines Providers ist die Dokumentation des Terraform Frameworks~\autocite{noauthor_terraform_framework_nodate}, in der Referenzen und Richtlinien für die Provider-Entwicklung zu finden sind. In diesem Abschnitt betrachten wir ein einfaches, aber in sich geschlossenes Provider-Beispiel. Wir beginnen mit einem Überblick über die Quell- und Verzeichnisstruktur und beschreiben anschließend die Quelltextdateien selbst. Die Quellen werden hier nicht vollständig gezeigt, sondern i.d.R.\ im Beispielrepository~\autocite{ecky-l_terraform-provider-example_nodate} referenziert. Wo es sinnvoll ist, werden kleine Ausschnitte als Listings gezeigt.

\subsubsection{Quellstruktur und Entwicklungszyklus}
\label{subsubsec:prov-sourc-struct}

Jedes Softwareprojekt besitzt eine bestimmte Struktur für Quell- und Hilfsdateien innerhalb eines Verzeichnisses. Diese wird einmal eingerichtet und ändert sich anschließend nur selten. Für einen Terraform-Provider folgt diese Struktur im Wesentlichen den Konventionen eines Go-Moduls~\autocite{noauthor_go_modules_nodate}. In unserem Beispiel kann die Struktur \href{https://github.com/ecky-l/terraform-provider-example/tree/main/src/tfp-example}{hier} im Beispielrepository~\autocite{ecky-l_terraform-provider-example_nodate} gefunden werden und sieht aus wie in Listing~\ref{lst:directory-structure}. Das Modul wird mit dem Befehl \verb'go mod init terraform-provider-<name>' initialisiert, wobei \emph{<name>} der Name des Providers ist. Ein Untermodul im Verzeichnis \emph{<name>} enthält die provider-spezifischen Quellen, hier im Verzeichnis \verb'example/'. Die Dateien \verb'go.mod' und \verb'go.sum' werden vom \verb'go'-Tool verwaltet und enthalten die Moduladäquenzen sowie deren Prüfsummen.

\begin{lstlisting}[label=lst:directory-structure]
tfp-example
|-- docs
|   |-- index.md
|-- example
|   |-- provider_test.go
|   |-- provider.go
|   |-- shop_article_resource_test.go
|   |-- shop_article_resource.go
|-- go.mod
|-- go.sum
|-- main.go
|-- Makefile
\end{lstlisting}


Die spezielle Datei \verb'main.go' enthält den Einstiegspunkt für den Provider. Eine \verb'main()'-Funktion darin startet den Provider-Server, mit dem das \verb'terraform'-Tool während der Laufzeit über \emph{Remote Procedure Calls} (\emph{RPC}) kommuniziert.

\begin{lstlisting}[label=lst:main]
func main() {
    providerserver.Serve(context.Background(), example.New, providerserver.ServeOpts{
        Address: "example.com/tfp-example/example",
    })
}
\end{lstlisting}

Während des Entwicklungszyklus ist es häufig notwendig, den aktuellen Stand zu kompilieren, zu testen und zu installieren. Um diese wiederkehrenden Schritte zu erleichtern, verwenden wir ein \emph{Makefile}, das das Komprimieren und Installieren der Binärdatei in das im Abschnitt~\ref{subsubsec:prov-inst} beschriebene Verzeichnis übernimmt. Dazu genügt im \verb'tfp-example'-Verzeichnis der Befehl \verb'make install'.

\subsubsection{Der Provider und seine Konfiguration}
\label{subsubsec:base-prov-conf}

Die meisten Provider kommunizieren in der Regel mit einem Backend und müssen dafür korrekt konfiguriert werden. Aus Sicht des Anwenders (siehe Abschnitt~\ref{subsec:practitioners-view}) geschieht dies über den \verb'provider'-Block. Für einen bestimmten Provider enthält dieser Block alle konfigurierbaren Parameter und deren Werte. Aus Entwicklersicht entspricht der Provider der Datei \verb'example/provider.go', die einige spezifische Implementierungen enthält.

Der Provider ist aus Entwicklersicht eine Struktur, die verschiedene Methoden aus dem Terraform Plugin Framework~\autocite{noauthor_terraform_framework_nodate} implementiert. In unserem Beispiel ist das die Struktur \verb'exampleProvider':

\begin{lstlisting}
type exampleProvider struct {
	host string
}
\end{lstlisting}


Diese Struktur wird als Empfänger (\emph{receiver}) an die implementierenden Methoden in \verb'provider.go' übergeben. Ein konkreter Wert wird mit der Funktion \verb'New()' erzeugt, die wiederum an die Methode \verb'providerserver.Serve()' aus Listing~\ref{lst:main} übergeben wird. Sie muss daher einen Typ vom Interface \verb'provider.Provider' zurückgeben, das alle notwendigen Methoden implementiert. Der Go-Compiler erzwingt diese Implementierungen und sie sind in der Datei \verb'provider.go' sichtbar:

\begin{description}
\item[\texttt{Metadata()}] gibt den Namen des Providers zurück.
\item[\texttt{Schema()}] definiert und gibt die Parameter zurück, die im \verb'provider'-Block konfiguriert werden können (siehe Listing~\ref{lst:example.tf}).
\item[\texttt{Configure()}] wird aufgerufen, wenn ein \verb'provider'-Block in den \verb'.tf'-Dateien vorkommt, und muss die Werte der Parameter lesen, validieren und speichern. In unserem Beispiel gibt es nur den Parameter \emph{host}. Wir prüfen, ob er eine gültige URL ist, und speichern ihn im Feld \verb'host' der Provider-Struktur. Die Parameter werden später über \verb'provider.ConfigureResponse' an Ressourcen weitergegeben.
\item[\texttt{DataSources()}] gibt eine Liste von Funktionen zurück, die vom Provider bereitgestellte \verb'data'-Blöcke erzeugen.
\item[\texttt{Resources()}] gibt eine Liste von Funktionen zurück, die vom Provider bereitgestellte \verb'resource'-Blöcke erstellen.
\end{description}

Die Rückgabewerte der letzten beiden Methoden müssen Listen von Funktionen sein, die Strukturen zurückliefern, welche die Interfaces \verb'datasource.DataSource' bzw. \verb'resource.Resource' implementieren. Diese definieren Methoden, die für die jeweiligen \verb'data'- und \verb'resource'-Blöcke während des Terraform-Lebenszyklus aufgerufen werden.

\subsubsection{Testen des Providers}
\label{subsubsec:note-on-testing}

Es ist gute Praxis, jede Funktionalität mit einem Unit- oder Integrationstest zu beginnen. Das ermuntert zu einem klaren Design und erleichtert das frühe Testen und Debuggen der Implementierung. Später hilft es bei der Vermeidung von Regressionen, wenn das Projekt wächst. Das Terraform SDK stellt ein Testframework~\autocite{noauthor_terraform_acceptance_testing_nodate} bereit, mit dem alle Aspekte eines Terraform-Lebenszyklus komfortabel getestet werden können. Zentral ist dabei ein Aufruf von \verb'resource.Test' oder \verb'resource.UnitTest' innerhalb eines Go-Tests mit einem Argument vom Typ \verb'resource.TestCase'. Dieser enthält eine Liste von Schritten, die in Reihenfolge ausgeführt werden. Die Schritte entsprechen weitgehend dem Vorgehen eines Anwenders beim Arbeiten mit Terraform: Ressourcen werden erstellt, aktualisiert und schließlich gelöscht. In einem \verb'resource.(Unit)Test' des Terraform-Frameworks erfolgt das Löschen der Ressourcen implizit nach allen anderen Schritten. Auch das Importieren von Ressourcen per ID kann über Parameter des \verb'resource.TestCase' gesteuert werden.

Ein Beispieltest für unsere Ressource (siehe Abschnitt~\ref{subsec:emphsh-reso}) befindet sich \href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/tfp-example/example/shop_article_resource_test.go}{hier}. Er definiert zwei Schritte in einem Testfall, die eine \emph{shop\_article}-Ressource erstellen und aktualisieren, bevor sie implizit gelöscht wird. Bei jedem Schritt werden Prüfungen ausgeführt, um sicherzustellen, dass die Ressourcenparameter korrekt gesetzt sind. Wenn solche Tests gleich am Anfang mit implementiert werden, können während der Entwicklung Break-Points in den Callbacks des Providers gesetzt und deren Verhalten zur Laufzeit direkt geprüft werden. Moderne IDEs ermöglichen es, die Tests direkt auszuführen und zu debuggen, ein großer Vorteil gegenüber dem wiederholten manuellen Installieren und Ausführen von Terraform über die Kommandozeile und dem Inspizieren von Log-Meldungen.

Es gibt zwei Möglichkeiten, den Code zu testen: Ein \verb'resource.UnitTest' wird immer beim Aufruf von \verb'go test' ausgeführt. Dabei sollte man vorsichtig sein, wenn dadurch ein echtes Backend angesprochen wird, denn dann werden die Ressourcen tatsächlich erstellt oder gelöscht, was nicht unbedingt immer erwünscht ist. Deswegen gibt es eine zweite Funktion \verb'resource.Test', die für Akzeptanztests verwendet werden kann und dementsprechend nur dann ausgeführt wird, wenn die Umgebungsvariable \verb'TF_ACC' gesetzt ist. Unit-Tests sollten mit gemockten Backends verwendet werden, während Akzeptanztests das Zusammenspiel mit echte Backends prüfen können. Zum Mocken von Backends gibt es verschiedene Strategien. Man kann man z.B.\ Tools wie \emph{Wiremock}~\autocite{noauthor_wiremock_nodate} einsetzen, die ein Backend simulieren und auf spezielle Anfragen genau definierte Antworten zurückliefern. Eine andere Möglichkeit ist die Verwendung eines Mocking-Frameworks, wie \emph{testify/mock}~\autocite{noauthor_testifymock_nodate}, um exakte Antworten auf spezielle Aufrufe des Mocks zu definieren und so z.B.\ das Verhalten von \verb'http.Client' oder anderen Komponenten der Go standard Library zu simulieren.

Obwohl die zweite Variante sehr mächtig ist, verwenden wir im Beispiel den ersten Ansatz mit \emph{Wiremock}. Der Vorteil ist, dass er einfach ist: Szenarios und entsprechende Antworten werden als JSON-Dateien im \verb'mappings/'-Verzeichnis definiert. Allerdings muss man \emph{Wiremock} vor jedem Test starten und darauf achten, dass sich die Szenarios im richtigen Status befinden.

\subsubsection{Die \emph{shop\_article}-Terraform-Ressource}
\label{subsec:emphsh-reso}

In unserem Beispiel implementieren wir eine Ressource mit dem Namen \emph{example\_shop\_article}. Der zugehörige Quellcode befindet sich in \href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/tfp-example/example/shop_article_resource.go}{dieser Datei} im Beispielrepository~\autocite{ecky-l_terraform-provider-example_nodate}.

Wie beim Provider selbst wird auch jede Ressource durch eine \emph{struct} dargestellt, die beliebige Daten enthalten kann. In unserem Beispiel sieht sie aus wie in Listing~\ref{lst:shopArticleResource}

\begin{lstlisting}[label=lst:shopArticleResource]
type shopArticleResource struct {
	provider *exampleProvider
}
\end{lstlisting}

Sie besitzt als einziges Feld einen Zeiger auf die Provider-Struct, zu der sie gehört. Das Feld wird während der Initialisierung des Providers durch die weiter unten beschriebene \verb'Configure()'-Methode befüllt. Eine weitere Struct, \verb'shopArticleResourceModel', repräsentiert eine konkrete Ressource dieses Typs mit ihren Werten. Dieses Struct wird für jede einzelne Ressource instanziiert und über die Argumente \verb'request' and \verb'response' an die Callbacks weiter gereicht. Es werden die Ressourcen-Parameter für zwei Status im Terraform Lebenszyklus abgebildet:

\begin{description}
\item[Im \emph{Plan}] enthält die Instanz den gewünschten Zustand der Ressource, abgeleitet aus den \verb'.tf'-Dateien.
\item[Im \emph{State}] enthält sie den aktuellen Zustand der Ressource im Terraform-State, basierend auf vorherigen Ausführungen. Ein leerer State wird für eine Ressource angelegt, die noch nicht existiert.
\end{description}

Beim Ausführen von \verb'terraform plan' werden Plan und State verglichen, um Abweichungen festzustellen. Wenn keine Unterschiede bestehen, ist alles synchron; andernfalls zeigt Terraform an, welche Änderungen erforderlich sind. Für unser Beispiel ist die Struktur in Listing~\ref{lst:shopArticleResourceModel} zu sehen.

\begin{lstlisting}[label=lst:shopArticleResourceModel]
type shopArticleResourceModel struct {
	ID          types.Int64  `tfsdk:"id"`
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
}
\end{lstlisting}

Die Felder im Struct sind mit \verb'tfsdk:*'-Tags versehen. Diese geben die Zuordnung zwischen Feldern aus dem \emph{Ressourcen-Schema}, wie z.B. denen in Listing~\ref{lst:example.tf}, und den jeweiligen Gegenstücken im Struct an.

Damit eine Ressource tatsächlich eingebunden wird, muss ihr Constructor in der Rückgabe von \verb'Resources()' (siehe Abschnitt~\ref{subsubsec:base-prov-conf}) enthalten sein. Dadurch wird sichergestellt, dass die Ressource die folgenden Methoden implementiert:

\begin{description}
\item[\texttt{Metadata()}] wird von Terraform aufgerufen um Metadaten des Ressourcentyps abzurufen. Vor allem registriert sie den Namen der Ressource und ermöglicht Definitionen wie im Listing~\ref{lst:example.tf}.
\item[\texttt{Configure()}] wird aufgerufen, wenn Terraform einen entsprechenden \verb'resource'-Block findet und ermöglicht die Übergabe von Provider-Parametern an die Ressource. In unserem Beispiel wird ein Zeiger auf die Provider-Struct gesetzt, über die man später den Backend-Host referenzieren kann.
\item[\texttt{Schema()}] definiert die möglichen Parameter für den Ressourcentyp und deren Einschränkungen mit einem Wert vom Typ \verb'schema.Schema'. In unserem Beispiel ist ein sog. \verb'PlanModifier' \verb'RequiresReplace' enthalten, der dazu führt, dass bei einer Änderung des Parameters die Ressource gelöscht und neu erzeugt wird. Andere Plan-Modifikatoren sind möglich und können auch selbst implementiert werden.
\item[\texttt{Create()}] wird aufgerufen, um eine Ressource des Typs im Backend zu erzeugen, wenn Terraform aufgrund der Planungsphase dies für nötig hält. Im Beispiel wird ein \verb'POST'-Aufruf an den Webservice gemacht. Nach der Erzeugung müssen die Parameter im State-Modell gesetzt werden und der State muss in der \emph{response} aktualisiert werden.
\item[\texttt{Delete()}] wird aufgerufen wenn eine Ressource im Backend gelöscht werden soll. Das geschieht im Wesentlichen durch ein \verb'terraform destroy' oder nachdem sie in den \verb'.tf'-Dateien eines Moduls entfernt wurde. Der Callback muss diese Operation implementieren, z.B.\ durch einen \verb'DELETE'-Aufruf an einer REST-API, wie im Beispiel.
\item[\texttt{Read()}] wird aufgerufen, um den Zustand einer Ressource im Backend abzufragen. Das ist der Fall, wenn die Ressource importiert werden soll oder eine Synchronisierung mit dem Terraform-State stattfindet. Wenn das Backend ein REST Webservice ist, wird üblicherweise ein \verb'GET'-Aufruf gemacht. In unserem Fall wird \verb'GET /articles/<id>' aufgerufen um den Shop-Artikel mit der ID \emph{1} abzurufen. Anschließend wird der State der Ressource im \emph{response}-Argument aktualisiert.
\item[\texttt{Update()}] wird aufgerufen, wenn Terraform eine Divergenz zwischen Plan und State festgestellt hat, um die Ressource zu aktualisieren. Der Callback muss die entsprechende Logik implementieren, z.B.\ durch einen \verb'PUT'-Aufruf wie im Falle unseres Beispiels.
\end{description}

Die Methoden interagieren eng mit ihren Argumenten. Insbesondere enthält der \verb'response'-Parameter Zeiger auf die Plan- und State Werte der Ressource u.a., so dass diese Werte aktualisiert werden können.

\paragraph{Fehlerbehandlung}

Das \verb'response'-Argument enthält auch ein Feld mit Namen \verb'Diagnostics', das zur Ausgabe von Informationen und Fehlermeldungen an den Benutzer dient. Fehler werden typischerweise über \verb'response.Diagnostics.AddError()' an den Benutzer gemeldet, wie im Listing~\ref{lst:errorHandling} für einen Fehler im JSON-Unmarshalling gezeigt wird.

\begin{lstlisting}[label=lst:errorHandling]
if err := dec.Decode(&respBody); err != nil {
    resp.Diagnostics.AddError("Error during article Create", fmt.Sprintf("Json unmarshalling error: %v", err))
    return
}
\end{lstlisting}

Wenn ein solcher Fehler auftritt, wird die entsprechende Nachricht während des Terraform-Laufs angezeigt:

\begin{lstlisting}
...
example_shop_article.example: Creating...
|
| Error: Error during article Create
|
|   with example_shop_article.example,
|   on main.tf line 14, in resource "example_shop_article" "example":
|   14: resource "example_shop_article" "example" {
|
| Json unmarshalling error: unexpected EOF
|
\end{lstlisting}

In unserem Beispiel sind die Callback-Implementierungen bewusst einfach gehalten. In realen Projekten würde man Backend-Aufrufe in Hilfsfunktionen auslagern und eine robustere Fehlerbehandlung implementieren. Für Demonstrationszwecke genügt jedoch dieser direkte Ansatz.

\section{Zusammenfassung}
\label{sec:summary}

Manchmal ist es notwendig, Infrastruktur als Code mit Terraform für Ressourcen zu verwalten, die nicht standardmäßig unterstützt werden, z.B.\ weil sie selbst entwickelt wurden. Terraform verfügt über einen leistungsfähigen Plugin-Mechanismus und ein gut dokumentiertes SDK, das die Entwicklung eigener, interner Provider für solche Fälle ermöglicht.

In diesem Artikel haben wir das Terraform-Provider-Framework anhand eines anschaulichen Beispiels vorgestellt. Ein Terraform-Provider namens ``example'' wurde entwickelt, der eine Ressource \emph{shop\_article} bereitstellt, die durch ein künstliches REST-Backend unterstützt wird. Das Backend wird in einem \emph{Wiremock}-Szenario simuliert. Wir haben gesehen, wie der gesamte Code strukturiert werden kann, wie Entwicklungsversionen eines Providers installiert, verwendet und getestet werden, sowie Tipps und bewährte Vorgehensweisen für die Nutzung des Terraform-Testframeworks.

Eine begleitende \emph{DataSource} für die \emph{article}-Entität ist nicht Teil dieses Beispiels. Nach der Lektüre dieses Artikels und einem Blick in die Quelltexte sollte deren Implementierung jedoch nicht schwierig sein und bleibt daher als Fingerübung für interessierte Leser.

\printbibliography[heading=bibintoc]

\end{document}
