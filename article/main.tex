\documentclass[paper=a4,11pt,numbers=noenddot]{article}
\linespread{1.2}
\usepackage[parfill]{parskip} % non-indented paragraphs with more space
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[pdftex]{color,graphicx}

\usepackage[autocite=plain, backend=biber, style=numeric, sorting=nyt]{biblatex}
\addbibresource{main.bib} % The filename of the bibliography

\usepackage{listings}
\renewcommand{\lstlistlistingname}{List of Listings}
\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\scriptsize,
  numbers=none,
  backgroundcolor=\color[rgb]{0.95,0.90,0.90},
  commentstyle=\color[rgb]{0,0.6,0},
  keywordstyle=\color[rgb]{0.2,0.6,1},
  breakatwhitespace=false,
  breaklines=true,
%  captionpos=b,
  keepspaces=true,
%  numbers=left,
%  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2
}
\lstset{style=mystyle}

\usepackage[plainpages=false,pdfpagelabels,hidelinks]{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  urlcolor=blue,
}
\urlstyle{same}

%% margins
\oddsidemargin 0cm
\evensidemargin 0cm
\textwidth 16cm
\topmargin 0cm
%\textheight 24.37cm

\title{Terraform Provider Development}
\author{Eckhard Lehmann}

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

blabla

\section{Technology Overview}
\label{sec:technology-overview}


\subsection{The Go Programming Language}
\label{subsec:go-progr-lang}

Go, or ``golang'' is a modern, general purpose programming language introduced by Google. It is a statically typed and compiled language, which means it comes with the advantage that type checking is done at compile time. Golang has its roots in C, Pascal/Oberon and languages that stem from the concept of \emph{communicating sequential processes} (CSP), like Squeak and Alef \cite{donovan_go_2016}. From the latter it inherits its model of concurrent programming, which is quite outstanding among programming languages and makes Go an interesting choice for parallel programming tasks.

When looking at golang code, the most prominent heritage is from the C programming language. Thus golang is sometimes referred to as \emph{C for the 21st century}. But despite the outside looks quite much like C, there is not much C under the hood. Go has garbage collection, object orientation, memory safety, type-safe pointers and functional elements, which means functions can be bound to arguments, return values and variables, including declaration scope. Additionally it comes with a modern tool set that enables dependency management, testing, documentation generation from source code comments, linting and other tasks to be performed in an everyday usage of the language. All this is combined in the \verb'go' tool, which is the entry- and starting point for every golang project.

The website \url{https://go.dev/} is the main entry point for resources to download and learn golang, including a nice tutorial called a \emph{Tour of Go}. For serious ambitions in developing terraform providers it is a good idea to look at this tutorial and get comfortable with the golang distribution and the \verb'go' tool at least, as everything around terraform and its providers is developed in golang.

\subsection{The \emph{terraform} tool and ecosystem}
\label{subsec:terr-tool-ecosyst}

Terraform is a tool for managing \emph{Infrastructure as Code} (\emph{IcA}). At the heart is a terraform \emph{state}, a JSON file with a specific structure, that describes the current state of a certain infrastructure in form of its \emph{resources} and a set of resource definitions in \verb'.tf' files inside a directory, called a \emph{terraform module}. To create a infrastructure module, files with the ending \verb'.tf', containing resource definitions are placed in a directory. As a simple, artificial example consider a resource \emph{employee} with certain attributes:

\begin{lstlisting}
resource "shop_article" "shampoo" {
  name        = "Princess Rosalea"
  description = "Child Shampoo & Conditioner"
}
\end{lstlisting}

In reality these are computer resources, such as networks, databases, virtual machine instances, etc. Terraform resources are used to describe conglomerations of computer infrastructure in cloud environments. Thus there is always some kind of \emph{backend} involved, usually a REST API, which implements the logic to provide the respective resources in a cloud environment.

The \verb'terraform' command is used to read the \verb'.tf' files in a directory, take the necessary actions to create the resources (i.e.\ calls the API endpoints), and store the state into a state file. This state file is by default a local JSON file called \verb'terraform.tfstate', but can be configured to reside in a remote location, such as an cloud storage bucket or a database. Whenever resources need to be changed or deleted, or additional resources should be created, the respective resource definitions in the \verb'tf' files can be edited, deleted or extended by new resources. A \verb'terraform apply' would then do three things:

\begin{enumerate}
\item\label{itm:tf-read} Get the current resources in the backend.
\item\label{itm:tf-compare} Do a three-way compare between the current state, the fetched real resources and the resource (\verb'tf') files, and then:
  \begin{itemize}
  \item Delete resources that are in the backend but not in the resource files.
  \item Create resources that are not in the backend, but in the resource files.
  \item Modify resources whose definition has changed in the resource files, compared to the previous definition in the state.
  \end{itemize}
\item\label{itm:tf-create-update} Store the new state in the state file.
\end{enumerate}

Terraform provides its functionality by means of a core component that reads the \verb'.tf' files and manages the state, and a set of plugins, which interact with various backends. These plugins are called \emph{providers}, as they provide the functionality of infrastructure management. They are decoupled from the terraform core and evolve independently. Providers are available for all well-known cloud providers and various other infrastructure providing entities, such as the IAM solution Keycloak \cite{team_keycloak_nodate} or the secret manager Vault \cite{noauthor_vault_nodate}.

An entry point for searching terraform providers and their documentation is the terraform provider registry~\cite{noauthor_terraform_registry_nodate}. There are numerous resources available on terraform with the main entry point being its homepage~\cite{noauthor_terraform_nodate}. A good introduction with live examples can also be found in~\cite{brikman_terraform_2022}.


\section{A Simple REST API Backend}
\label{sec:simple-rest-api}

The purpose of terraform is to manage infrastructure as code, that is to create, modify and delete infrastructure \emph{resources}. How exactly these resources look like, is not strictly specified. On a cloud provider like AWS or GCP it might be virtual hardware resources, or firewall and permission rules, while on a keycloak instance it might be OpenID Connect Clients and appropriate credentials. On a local machine it might be files in the file system, service management scripts or mandatory access control policies (such as for SElinux).

However, to keep things simple we will consider a simple REST API backend for the purpose of this demonstration, where the resources are shop articles. Moreover we will not even create this backend - instead we will mock it. Wiremock~\cite{noauthor_wiremock_nodate} is a powerful tool and library, which fulfills the sole objective to return specific responses based on certain matching input criteria. It is normally used to unit-test API clients in a variety of programming languages, when the genuine API backend is not (yet) available or should not be stressed for testing.

\paragraph{The \emph{article} REST Resource}

Our REST API manages a resource called \emph{shop\_article}, which is essentially an online shop article. It contains an ID, a name and a description. Articles can be created, fetched by ID, updated and deleted. Although this is oversimplified, it is enough for the purpose of an illustrative example.

The management of our REST resource can be described as a state machine: Initially there is no article, so a \verb'GET' call to a specific ID, say \emph{1}, will return a HTTP status 404. This is state $S_0$, or ``Started''. When a \verb'POST' is made to the \verb'/articles' endpoint, an article is created initially with a specific ID, say \emph{1}, and the state for this entity changes to $S_1$, or \emph{Article added}. A \verb'GET' call to \verb'/articles/1' in $S_1$ retrieves the initially created article. Now there are two possibilities to change the state again: A \verb'PUT' call to \verb'/articles/1' modifies the article and changes the state to $S_2$, or \emph{Article modified}. Subsequent \verb'GET' calls to \verb'/articles/1' will retrieve the modified article. A \verb'DELETE' call to \verb'/articles/1' will ``delete'' the article in either $S_1$ or $S_2$ and reset the state to $S_0$. Subsequent modifications or specific create/update parameters are not considered.

In Wiremock this can be depicted as a \emph{Scenario}~\cite{noauthor_wiremock_stateful_behavior_2025}. Our article is a children shampoo and the corresponding file can be found~\href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/wiremock/mappings/shampoo.json}{here} in the github repository of this example~\cite{ecky-l_terraform-provider-example_nodate}. Create a directory \emph{mappings} and place the file into this directory. Then download the standalone binary from the \emph{Wiremock} homepage, place it aside the \emph{mappings} directory and start wiremock up with \verb'java -jar wiremock-standalone-<version>.jar'. You should see the service starting up and listening on port \verb'8080'. Then you can verify whether our new ``API backend'' works:

\begin{lstlisting}[language=bash]
$ curl -s localhost:8080/articles/1 | jq
{
  "error": "not found"
}
$ curl -sX POST localhost:8080/articles | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner"
}
$ curl -s localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner."
}
$ curl -sX PUT localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner. Soft on the skin, soft on the environment."
}
$ curl -s localhost:8080/articles/1 | jq
{
  "id": 1,
  "name": "Princess Rosalea",
  "description": "Child Shampoo & Conditioner. Soft on the skin, soft on the environment."
}
$ curl -X DELETE localhost:8080/articles/1
$ curl -s localhost:8080/articles/1 | jq
{
  "error": "not found"
}
\end{lstlisting}

This is about all we need to back the \emph{shop\_article} resource for our demo terraform provider, which will be the topic of the next sections.

\section{Creating a Terraform Provider with one Resource}
\label{sec:creat-terr-prov}

Communication between the terraform core and the providers is implemented via an RPC interface and callback functions that are executed at specific points in the interaction~\ref{itm:tf-read}-~\ref{itm:tf-create-update} in Section~\ref{subsec:terr-tool-ecosyst}.

\subsection{The Practitioner's View}
\label{subsec:practitioners-view}

A \emph{practitioner} is, as frequently denoted in the terraform plugin framework~\cite{noauthor_terraform_framework_nodate}, the person who manages infrastructure as code in terraform. His point of view is a set of \verb'.tf' files in a directory, which makes up a terraform module.

\subsubsection{An example terraform module}
\label{subsubsec:an-example-terraform}

For our example, there is a terraform module (directory) with one file \verb'main.tf'. The content of this file looks like listing~\ref{lst:example.tf} and can be found~\href{https://github.com/ecky-l/terraform-provider-example/blob/main/src/exampletf}{here} in the github repository~\cite{ecky-l_terraform-provider-example_nodate}.

\begin{lstlisting}[label=lst:example.tf]
terraform {
  required_providers {
    example = {
      source  = "example.com/tfp-example/example"
      version = "0.0.1"
  }
}

provider "example" {
  host = "http://localhost:8080"
}

resource "example_shop_article" "example" {
  name        = "Princess Rosalea"
  description = "Child Shampoo & Conditioner"
}
\end{lstlisting}

Each terraform main module\footnote{There are also sub modules, which do not necessarily contain all configuration options when used in other (main) modules.} contains at least one \verb'terraform' block in which the \verb'required_providers' are configured. Each provider is listed by its name, the source where it can be downloaded. The required version is optional, otherwise the latest version is resolved and used. It follows an optional \verb'provider' block for each required provider, in which special configuration can be passed. Afterwards, the resources and data sources of the provider can be used.

A \verb'terraform init' in the directory with the terraform sources fetches the provider from the specified source and extracts it in the local \emph{.terraform} directory. A subsequent \verb'terraform plan' shows what is going to happen, i.e.\ creating the specified resource. Then, a \verb'terraform apply' would actually execute the plan. When these commands are run, terraform communicates with the provider and calls a set of functions that are described in the following.


\subsubsection{Provider Installation}
\label{subsubsec:prov-inst}

The \verb'source' parameter in the \verb'required_providers' block has a special structure which specifies where the provider's binary release can be found. It consists of three parts:

\begin{itemize}
\item The domain where the provider release resides.
\item A name space for the provider, usually a team or company who is maintaining the provider
\item The provider's name
\end{itemize}

As a consequence, the source has always the schema \emph{<domain>/<namespace>/<provider name>}. Most providers are hosted on the terraform provider registry~\cite{noauthor_terraform_registry_nodate}, therefore the domain \emph{registry.terraform.io} for those providers can be omitted for convenience. Otherwise it must be a valid domain under which a web server is hosting the provider binaries within the directory structure \emph{<namespace>/<provider name>}. In there, the releases must have a name that follows the schema \emph{terraform-provider-<name>\_<version>\_<arch>.zip}. The \emph{<name>} here is same name as in the third component of the provider URL, \verb'<version>' is the provider version, following a semantic versioning schema~\cite{preston-werner_semantic_versioning_nodate} and \emph{<arch>} refers to the architecture and operating system for which the provider binary was compiled.

Although recommended, hosting the provider on a domain is strictly speaking not necessary. Alternatively it is possible to keep the zipped binary in a local directory and configure that directory as a \verb'filesystem_mirror'. The process and possibilities are described in~\cite{noauthor_terraform_provider_installation_nodate} and the simplest one is to place the zipped binary in a directory that follows the three-component schema of the provider location underneath \verb'~/.terraform.d/plugins/', where \verb'~' is the users home directory. In our example, with version \emph{0.0.1} and on macOS this would look like:

\begin{lstlisting}
/Users/<youruser>/.terraform.d/
|-- checkpoint_cache
|-- checkpoint_signature
|-- plugins
    |-- example.com
        |-- tfp-example
            |-- example
            |-- terraform-provider-example\_0.0.1\_darwin\_arm64.zip
\end{lstlisting}

The \verb'<arch>' depends on the platform where the provider is compiled and used. A simple trick is to use the \verb'go' tool itself to determine the architecture and OS, since it outputs these values as needed, i.e.\ in a shell:

\begin{lstlisting}[language=bash,basicstyle=\ttfamily\footnotesize,numbers=none]
go version | cut -d' ' -f4 | sed -E 's/\//_/'
\end{lstlisting}

This trick is part of the \emph{make} process to install the provider, which we will see in the next section.

\subsection{Provider Sources Structure and Development Cycle}
\label{subsec:prov-sourc-struct}

Every software project has some kind of structure for source and auxiliary files inside a directory, that is set up once and then does not change much. For a terraform provider this does basically follow the conventions of a go module~\cite{noauthor_go_modules_nodate} and in our example the structure can be found \href{https://github.com/ecky-l/terraform-provider-example/tree/main/src/tfp-example}{here} in the example repository~\cite{ecky-l_terraform-provider-example_nodate}. It looks like listing~\ref{lst:directory-structure}. The module is initialized with the command \verb'go mod init terraform-provider-<name>', with \emph{<name>} being the provider name. A sub module of directory \emph{<name>} contains the provider specific sources, here inside the \verb'example/' directory. The files \verb'go.mod' and \verb'go.sum' are managed by the \verb'go' tool and contain module dependencies and their check sums.

\begin{lstlisting}[label=lst:directory-structure]
tfp-example
|-- docs
|   |-- index.md
|-- example
|   |-- provider.go
|-- go.mod
|-- go.sum
|-- main.go
|-- Makefile
\end{lstlisting}

The special file \verb'main.go' contains the entry point for the provider. A \verb'main()' function inside it starts the provider server, with which the \verb'terraform' tool communicates during runtime via \emph{Remote Procedure Calls} (\emph{RPC}):

\begin{lstlisting}[label=lst:main]
func main() {
    providerserver.Serve(context.Background(), example.New, providerserver.ServeOpts{
        Address: "example.com/tfp-example/example",
    })
}
\end{lstlisting}

During the development cycle it is frequently necessary to compile, test and install the latest binary. We use a \emph{Makefile} to ease the burden of these frequent cycles, which takes care of compressing and installing the binary in the directory mentioned in Section~\ref{subsubsec:prov-inst}. To do this, you can just type \verb'make install' inside the \verb'tfp-example' directory.

\subsection{Base Provider Configuration}
\label{subsec:base-prov-conf}

Most providers do usually communicate with some kind of backend and must be configured appropriately to perform this functionality. From the practitioner's point of view (see Section~\ref{subsec:practitioners-view}) this is done with the \verb'provider' block. For a particular provider this block contains all configurable parameters and their values. From the provider developers point of view, the provider looks like the \verb'example/provider.go' file and it contains a few specific implementations.

A provider in the developers view is a structure that implements various methods from the terraform plugin framework~\cite{noauthor_terraform_framework_nodate}. In our case this is the \verb'exampleProvider' struct:

\begin{lstlisting}
type exampleProvider struct {
	host string
}
\end{lstlisting}

This struct is passed as a receiver to the implementing methods in \verb'provider.go'. A concrete value is created with the \verb'New()' function, which in turn is passed to the \verb'providerserver.Serve()' method in listing~\ref{lst:main} and must therefore return a \verb'provider.Provider' interface type that implicitly implements all the methods for that interface. For this reason the go compiler enforces the implementation of all the necessary methods, which can be seen in \verb'provider.go'.

\begin{description}
\item[Metadata()] returns the provider name.
\item[Schema()] specifies and returns the parameters that can be configured in the \verb'provider' block for the resource (see listing~\ref{lst:example.tf}).
\item[Configure()] is called when a \verb'provider' block occurs in the \verb'.tf' sources and must take care of reading, validating and storing the values for the configurable parameters. In our example there is only one parameter \emph{host}. We check whether it is a valid URL and store it in the \verb'host' field in the provider struct receiver. Typically the configured values must be passed to the provider's resources later on, and this is done via fields in the \verb'provider.ConfigureResponse' pointer argument that is passed to \verb'Configure()'. We will see later, how values are retrieved during resource or data source configuration.
\item[DataSources()] returns a list of functions that create the \verb'data' source blocks, which are implemented by the provider.
  \item[Resources()] returns a list of functions that create the \verb'resource' blocks, which are implemented by the provider.
\end{description}

The return arguments of the latter two methods must be lists of functions, which create \verb'datasource.DataSource' and \verb'resource.Resource' go interface types respectively. They specify methods which must be implemented for the respective \verb'data' and \verb'resource' blocks, and are called during the lifecycle of a terraform run.

\subsection{The \emph{shop\_article} Terraform Resource}
\label{subsec:emphsh-reso}



\section{Summary}

blabla

\printbibliography

\end{document}
